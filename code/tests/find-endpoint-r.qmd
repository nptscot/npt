---
juptyer:
  kernels: python3
---

See https://github.com/luukvdmeer/sfnetworks/blob/main/vignettes/sfn02_preprocess_clean.Rmd and the equivalent python code.

```{r}
library(sfnetworks)
library(sf)
library(tidygraph)
library(tidyverse)
# Define the URL
url = "https://github.com/nptscot/npt/releases/download/join_orcp/orcp_city_boundary.geojson"

# Download the file from the URL
gdf_all = read_sf(url)

url = "https://github.com/nptscot/npt/releases/download/join_orcp/OS_Edin.geojson"
OS_inter = read_sf(url)

url = "https://github.com/nptscot/npt/releases/download/join_orcp/OSM_Edin.geojson"
OSM_inter = sf::read_sf(url)

# Filter the GeoDataFrame to only include the component of interest, change the value for another component
gdf = gdf_all |> 
  filter(component == 9)
merged_lines = st_union(gdf)

# # Attempt to merge into a single continuous line if possible
# single_line = linemerge(merged_lines)
```


```{r}
gdf_sfn = gdf |> 
  as_sfnetwork()
gdf_simple = gdf_sfn |> 
  activate("edges") |>
  filter(!edge_is_multiple()) |>
  filter(!edge_is_loop()) 
# Let's see how much smaller the simple network is:
object.size(gdf_sfn) / object.size(gdf_simple)
plot(gdf_simple)
```

Removing pseudo-nodes

```{r}
gdf_smoothed = convert(gdf_simple, to_spatial_smooth)
plot(gdf_smoothed)
```

Simplifiying intersections:

```{r}
node_coords = gdf_smoothed |>
  activate("nodes") |>
  st_coordinates()
clusters = dbscan::dbscan(node_coords, eps = 20, minPts = 1)$cluster

clustered = gdf_smoothed |>
  activate("nodes") |>
  mutate(cls = clusters)

clustered = clustered |>
  mutate(cmp = group_components())

select(clustered, cls, cmp)
contracted = convert(
  clustered,
  to_spatial_contracted,
  cls, cmp,
  simplify = TRUE
)
plot(contracted)
```

Now we'll calculate the degree of each node:

```{r}
node_degree = contracted |>
  activate("nodes") |>
  mutate(degree = centrality_degree()) |>
  # Keep only the degree column:
  select(degree) |>
  # Extract nodes to sf:
  st_as_sf()
plot(node_degree)
```

nodes with only 1 degree are endpoints.
Extract and plot them over the network:

```{r}
endpoints = node_degree |> 
  filter(degree < 1)
gdf_simple |> 
  plot()
endpoints |>
  sf::st_geometry() |>
  plot(add = TRUE, col = "red", pch = 19, cex = 2)

```

With centrality betweenness:

```{r}
node_degree = contracted |>
  activate("nodes") |>
#   mutate(degree = centrality_degree()) |>
  mutate(degree = centrality_betweenness()) |>

  # Keep only the degree column:
  select(degree) |>
  # Extract nodes to sf:
  st_as_sf()
plot(node_degree)
```

nodes with only 1 degree are endpoints.
Extract and plot them over the network:

```{r}
endpoints = node_degree |> 
  filter(degree == 0)
gdf_simple |> 
  plot()
# Save for viewing
gdf_simple_linestrings = gdf_simple |> 
  activate("edges") |>
  st_as_sf()
mapview::mapview(gdf_simple_linestrings) +
  mapview::mapview(endpoints)
endpoints |>
  sf::st_geometry() |>
  plot(add = TRUE, col = "red", pch = 19, cex = 2)

```

We'll create an outline of the object with `concaveman`:

```{r}
if (!requireNamespace("concaveman", quietly = TRUE)) {
  install.packages("concaveman")
}
library(concaveman)
gdf_concave = concaveman::concaveman(gdf_simple_linestrings, concavity = 3)
# plot(gdf_concave)
gdf_concave_linestring = sf::st_cast(gdf_concave, "LINESTRING") |>
  st_zm()
endpoints_on_outline = endpoints[
  gdf_concave_linestring,
  op = st_is_within_distance,
  dist = 1
]
mapview::mapview(gdf_concave_linestring) +
  mapview::mapview(endpoints_on_outline)
```

